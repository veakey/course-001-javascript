<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Le Robot et le Codeur</title>
  <link rel="stylesheet" href="../shared/css/glassui.css">
  <link rel="stylesheet" href="../shared/css/common.css">
  <link rel="stylesheet" href="css/style.css">
  <!-- CodeMirror -->
  <link rel="stylesheet" href="../shared/css/codemirror/codemirror.css">
  <link rel="stylesheet" href="../shared/css/codemirror/theme/monokai.css">
  <script src="../shared/js/codemirror/codemirror.js"></script>
  <script src="../shared/js/codemirror/mode/javascript.js"></script>
</head>
<body>
  <div class="container">
    <div class="terminal-panel glass-panel">
      <h2 style="margin-bottom: 16px; color: var(--text-primary);">Terminal</h2>
      <div id="code-editor"></div>
      <button id="execute-btn" class="glass-button primary">Ex√©cuter</button>
      <div id="output" class="glass-panel" style="margin-top: 16px; padding: 16px;"></div>
    </div>
    <div class="game-panel glass-panel">
      <h2 style="margin-bottom: 16px; color: var(--text-primary);">Le Robot</h2>
      <canvas id="game-canvas" width="600" height="600"></canvas>
      <div id="game-message" style="text-align: center; font-size: 24px; font-weight: bold; margin: 16px 0; min-height: 32px; display: none;"></div>
    </div>
  </div>
  <script type="text/plain" id="game-code">
// Le Robot et le Codeur
// D√©placez le robot en utilisant les fonctions avancer(), reculer(), tournerGauche(), tournerDroite()

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

// Configuration de la grille
const tileSize = 40;
const tileCountX = Math.floor(canvas.width / tileSize);
const tileCountY = Math.floor(canvas.height / tileSize);

// √âtat du robot (coordonn√©es grille)
let robotGridX = Math.floor(tileCountX / 2);
let robotGridY = Math.floor(tileCountY / 2);
let robotAngle = 0; // Angle en degr√©s (0 = vers la droite)
const robotSize = 30;

// Point d'arriv√©e
let targetGridX = -1; // -1 indique que le point n'a pas encore √©t√© g√©n√©r√©
let targetGridY = -1;
let gameWon = false;

// Queue d'instructions pour l'animation
let instructionQueue = [];
let isExecuting = false;
const DELAY_MS = 100;

// Position initiale du robot (pour calculer la distance minimale)
const initialRobotX = Math.floor(tileCountX / 2);
const initialRobotY = Math.floor(tileCountY / 2);

// Fonction pour v√©rifier si une position est valide
function estPositionValide(x, y) {
  // V√©rifier que la position est au moins √† 3 cases des bords
  if (x < 3 || x >= tileCountX - 3 || y < 3 || y >= tileCountY - 3) {
    return false;
  }
  
  // V√©rifier que la distance avec le robot initial est >= 3
  const distance = Math.abs(x - initialRobotX) + Math.abs(y - initialRobotY);
  return distance >= 3;
}

// Fonction pour g√©n√©rer le point d'arriv√©e
function genererPointArrivee(x, y) {
  // Si x et y sont fournis, utiliser ces positions
  if (x !== undefined && y !== undefined) {
    // Valider la position fournie
    if (estPositionValide(x, y)) {
      targetGridX = x;
      targetGridY = y;
      console.log(`Point d'arriv√©e d√©fini √† (${targetGridX}, ${targetGridY})`);
      return;
    } else {
      console.warn(`Position (${x}, ${y}) n'est pas valide. G√©n√©ration d'une position al√©atoire √† la place.`);
      // Continuer pour g√©n√©rer une position al√©atoire
    }
  }
  
  // Ne pas r√©g√©n√©rer si un point d'arriv√©e existe d√©j√† et que le jeu n'est pas gagn√©
  if (targetGridX >= 0 && targetGridY >= 0 && !gameWon) {
    console.log(`Point d'arriv√©e d√©j√† d√©fini √† (${targetGridX}, ${targetGridY}). Utilisation de la position existante.`);
    return;
  }
  
  const positionsValides = [];
  
  // G√©n√©rer toutes les positions valides (au moins 3 cases des bords)
  for (let posX = 3; posX < tileCountX - 3; posX++) {
    for (let posY = 3; posY < tileCountY - 3; posY++) {
      // Calculer la distance de Manhattan avec le robot initial
      const distance = Math.abs(posX - initialRobotX) + Math.abs(posY - initialRobotY);
      
      // V√©rifier que la distance est >= 3
      if (distance >= 3) {
        positionsValides.push({ x: posX, y: posY });
      }
    }
  }
  
  // Choisir une position al√©atoire parmi les positions valides
  if (positionsValides.length > 0) {
    const positionAleatoire = positionsValides[Math.floor(Math.random() * positionsValides.length)];
    targetGridX = positionAleatoire.x;
    targetGridY = positionAleatoire.y;
    console.log(`Point d'arriv√©e g√©n√©r√© al√©atoirement √† (${targetGridX}, ${targetGridY})`);
  } else {
    // Fallback si aucune position valide (ne devrait pas arriver avec une grille 15x15)
    targetGridX = tileCountX - 4;
    targetGridY = tileCountY - 4;
    console.warn('Aucune position valide trouv√©e, utilisation d\'une position par d√©faut');
  }
}

// Fonction pour ex√©cuter la queue d'instructions avec d√©lai
async function executerQueue() {
  if (isExecuting) return;
  isExecuting = true;
  
  while (instructionQueue.length > 0) {
    const instruction = instructionQueue.shift();
    instruction();
    dessiner();
    await new Promise(resolve => setTimeout(resolve, DELAY_MS));
  }
  
  isExecuting = false;
}

// Fonction pour v√©rifier la victoire
function verifierVictoire() {
  if (robotGridX === targetGridX && robotGridY === targetGridY && !gameWon) {
    victoire();
  }
}

// Fonction de victoire
function victoire() {
  gameWon = true;
  const gameMessage = document.getElementById('game-message');
  if (gameMessage) {
    gameMessage.textContent = 'üéâ F√©licitations! Vous avez gagn√©! üéâ';
    gameMessage.style.display = 'block';
    gameMessage.style.color = '#4ade80'; // Vert
    gameMessage.style.textAlign = 'center';
    gameMessage.style.fontSize = '24px';
    gameMessage.style.fontWeight = 'bold';
    gameMessage.style.margin = '16px 0';
  }
  console.log('Victoire! Le robot a atteint le point d\'arriv√©e!');
}

// Fonctions de mouvement (ajoutent √† la queue)
function avancer() {
  if (gameWon) return;
  
  instructionQueue.push(() => {
    // Calculer la direction de d√©placement selon l'angle
    let deltaX = 0;
    let deltaY = 0;
    
    if (robotAngle === 0) {
      deltaX = 1; // Droite
    } else if (robotAngle === 90 || robotAngle === -270) {
      deltaY = 1; // Bas
    } else if (robotAngle === 180 || robotAngle === -180) {
      deltaX = -1; // Gauche
    } else if (robotAngle === 270 || robotAngle === -90) {
      deltaY = -1; // Haut
    }
    
    // D√©placer d'une case dans la grille
    const newX = robotGridX + deltaX;
    const newY = robotGridY + deltaY;
    
    // V√©rifier les limites
    if (newX >= 0 && newX < tileCountX && newY >= 0 && newY < tileCountY) {
      robotGridX = newX;
      robotGridY = newY;
    }
    
    console.log(`Robot avance. Position grille: (${robotGridX}, ${robotGridY})`);
    
    // V√©rifier la victoire
    verifierVictoire();
  });
  
  executerQueue();
}

function reculer() {
  if (gameWon) return;
  
  instructionQueue.push(() => {
    // Calculer la direction de d√©placement inverse selon l'angle
    let deltaX = 0;
    let deltaY = 0;
    
    if (robotAngle === 0) {
      deltaX = -1; // Gauche
    } else if (robotAngle === 90 || robotAngle === -270) {
      deltaY = -1; // Haut
    } else if (robotAngle === 180 || robotAngle === -180) {
      deltaX = 1; // Droite
    } else if (robotAngle === 270 || robotAngle === -90) {
      deltaY = 1; // Bas
    }
    
    // D√©placer d'une case dans la grille
    const newX = robotGridX + deltaX;
    const newY = robotGridY + deltaY;
    
    // V√©rifier les limites
    if (newX >= 0 && newX < tileCountX && newY >= 0 && newY < tileCountY) {
      robotGridX = newX;
      robotGridY = newY;
    }
    
    console.log(`Robot recule. Position grille: (${robotGridX}, ${robotGridY})`);
    
    // V√©rifier la victoire
    verifierVictoire();
  });
  
  executerQueue();
}

function tournerGauche() {
  if (gameWon) return;
  
  instructionQueue.push(() => {
    robotAngle -= 90;
    console.log(`Robot tourne √† gauche. Angle: ${robotAngle}¬∞`);
  });
  
  executerQueue();
}

function tournerDroite() {
  if (gameWon) return;
  
  instructionQueue.push(() => {
    robotAngle += 90;
    console.log(`Robot tourne √† droite. Angle: ${robotAngle}¬∞`);
  });
  
  executerQueue();
}

function dessinerDrapeau() {
  // Convertir coordonn√©es grille en pixels (centre de la case)
  const targetX = targetGridX * tileSize + tileSize / 2;
  const targetY = targetGridY * tileSize + tileSize / 2;
  
  // Dessiner le m√¢t du drapeau
  ctx.strokeStyle = '#8b4513'; // Marron
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(targetX - tileSize / 2 + 5, targetY - tileSize / 2);
  ctx.lineTo(targetX - tileSize / 2 + 5, targetY + tileSize / 2);
  ctx.stroke();
  
  // Dessiner le drapeau (triangle)
  ctx.fillStyle = '#ff4444'; // Rouge
  ctx.beginPath();
  ctx.moveTo(targetX - tileSize / 2 + 5, targetY - tileSize / 2);
  ctx.lineTo(targetX - tileSize / 2 + 5, targetY - tileSize / 2 + tileSize / 2);
  ctx.lineTo(targetX + tileSize / 2 - 5, targetY - tileSize / 2 + tileSize / 4);
  ctx.closePath();
  ctx.fill();
  
  // Bordure du drapeau
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  ctx.stroke();
}

function dessiner() {
  // Effacer le canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Dessiner la grille
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= canvas.width; i += tileSize) {
    ctx.beginPath();
    ctx.moveTo(i, 0);
    ctx.lineTo(i, canvas.height);
    ctx.stroke();
  }
  for (let i = 0; i <= canvas.height; i += tileSize) {
    ctx.beginPath();
    ctx.moveTo(0, i);
    ctx.lineTo(canvas.width, i);
    ctx.stroke();
  }
  
  // Dessiner le drapeau (point d'arriv√©e)
  dessinerDrapeau();
  
  // Convertir coordonn√©es grille en pixels (centre de la case)
  const robotX = robotGridX * tileSize + tileSize / 2;
  const robotY = robotGridY * tileSize + tileSize / 2;
  
  // Dessiner le robot
  ctx.save();
  ctx.translate(robotX, robotY);
  ctx.rotate((robotAngle * Math.PI) / 180);
  
  // Corps du robot (carr√©)
  ctx.fillStyle = '#4a9eff';
  ctx.fillRect(-robotSize / 2, -robotSize / 2, robotSize, robotSize);
  
  // Bordure
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  ctx.strokeRect(-robotSize / 2, -robotSize / 2, robotSize, robotSize);
  
  // Direction (fl√®che)
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(robotSize / 2 - 5, 0);
  ctx.lineTo(robotSize / 2 - 15, -8);
  ctx.lineTo(robotSize / 2 - 15, 8);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
}

// Initialisation
genererPointArrivee();
dessiner();
console.log('Robot initialis√© au centre. Utilisez avancer(), reculer(), tournerGauche(), tournerDroite()');
console.log(`Objectif: Atteindre le point d'arriv√©e √† (${targetGridX}, ${targetGridY})`);
  </script>
  <script src="../shared/js/terminal.js"></script>
  <script>
    const gameJsPath = 'js/game.js';
    document.addEventListener('DOMContentLoaded', () => {
      const codeEditor = document.getElementById('code-editor');
      const executeBtn = document.getElementById('execute-btn');
      const output = document.getElementById('output');
      if (codeEditor && executeBtn && output) {
        window.terminal = new Terminal('code-editor', 'execute-btn', 'output', gameJsPath);
      }
    });
  </script>
</body>
</html>
